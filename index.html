<link rel=stylesheet href=style.css>
<div id=v>
<div id=devil></div>
<canvas id=canvas width=800 height=600></canvas>
</div>

<script>

// Keyboard controls (Up Left Down Right Space)
u=r=d=l=s=0;
onkeydown=onkeyup=e=>this['s****lurd************************l**r************l*d***u**u'[e.which-32]]=e.type[5];


// Render hero and update its hitbox if it is the current one
hero = (x, y, arms, legs, mirror_h, mirror_v, current = 1) => {
  ctx.save();

  // Position the hero:
  
  // Reversed gravity
  if(mirror_v){
    
    /*// Look left
    if(mirror_h) {
      ctx.translate(x+70,y+115);
      ctx.scale(1.5,1.5);
    }
    
    // Look right
    else {
      ctx.translate(x+30,y+115);
      ctx.scale(-1.5,1.5);
    }
    ctx.rotate(Math.PI);*/
  }
  
  // Normal gravity
  else {
  
    // Look left
    if(mirror_h) {
      ctx.translate(x+15,y-55);
      ctx.scale(-1.5,1.5);
    }
    
    // Look right
    else {
      ctx.translate(x-15,y-55);
      ctx.scale(1.5,1.5);
    }
    
    // Compute hitbox
    if(current){
      
      // Hold a cube
      if(arms == "hold"){
      
        // Look left
        if(hero_h){
          tl = [hero_x + -45, hero_y - 45];
          tr = [hero_x + 25, hero_y - 45];
          bl = [hero_x + -15, hero_y + 45];
          br = [hero_x + 15, hero_y + 45];
          ml = [hero_x + -45, hero_y];
          mr = [hero_x + 15, hero_y];
        }
        
        // Look right
        else {
          tl = [hero_x + -15, hero_y - 45];
          tr = [hero_x + 45, hero_y - 45];
          bl = [hero_x + -15, hero_y + 45];
          br = [hero_x + 15, hero_y + 45];
          ml = [hero_x + -15, hero_y];
          mr = [hero_x + 45, hero_y];
        }
      }
      
      // Not holding stuff
      else {
        tl = [hero_x + -15, hero_y - 35];
        tr = [hero_x + 15, hero_y - 35];
        bl = [hero_x + -15, hero_y + 45];
        br = [hero_x + 15, hero_y + 45];
        ml = [hero_x + -15, hero_y];
        mr = [hero_x + 15, hero_y];
      }
    }
  }
  
  // Draw:
  // Body
  ctx.fill(new Path2D("M17 15L20 20L16 21ZM8 15L6 11L9 13L8 10L11 13L12 9L13 13L15 9L15 13L17 10L17 13L19 10L18 15L17 25A4 4 0 0 1 22 30L17 32L17 44A2 2 0 0 1 8 44L8 32L3 28A7 9 0 0 1 9 25Z")); // body
  
  // Arms
  if(arms == "idle" || arms == "walk1"){
    ctx.fill(new Path2D("M3 28L3 47A1 1 0 1 0 8 47L8 25Z"));
    ctx.fill(new Path2D("M22 29L22 46A1 1 0 0 1 17 46L17 25Z"));
  }
  else if(arms == "hold") {
    ctx.fill(new Path2D("M3 28L7 41L23 41A3 3 0 0 0 23 34L11 34L9 26Z"));
    ctx.fill(new Path2D("M15 26L19 38L32 38A2 2 0 0 0 32 32L24 32L20 26Z"));
  }
  else if(arms == "walk0") {
    ctx.fill(new Path2D("M16 27L18 46A1 1 0 0 0 24 44L21 26Z"));
    ctx.fill(new Path2D("M4 28L1 47A1 1 0 0 0 6 48L10 26Z"));
  }
  else if(arms == "walk2") {
    ctx.fill(new Path2D("M4 28L6 49A2 2 0 0 0 12 48L9 26Z"));
    ctx.fill(new Path2D("M16 26L14 45A1 1 0 0 0 18 47L21 28Z"));
  }
  
  // Legs
  if(legs == "idle"){
    ctx.fill(new Path2D("M12 45L12 71A2 1 0 1 0 17 71L17 43Z"));
    ctx.fill(new Path2D("M9 44L9 70A2 2 0 1 0 14 70L14 45Z"));
  }
  else if(legs == "walk2"){
    ctx.fill(new Path2D("M9 46L13 71A4 3 0 0 0 20 69L14 46Z"));
    ctx.fill(new Path2D("M11 45L6 68A2 2 0 0 0 11 70L16 46Z"));
  }
  else if(legs == "walk0"){
    ctx.fill(new Path2D("M9 46L10 69A3 5 0 0 0 15 69L14 46Z"));
    ctx.fill(new Path2D("M12 47L14 56L6 64A1 1 0 0 0 10 68L21 57L15 46Z"));
  }
  else if(legs == "jump" || legs == "walk1"){
    ctx.fill(new Path2D("M9 46L11 58L8 68A2 2 0 0 0 12 70L16 58L13 46Z"));
    ctx.fill(new Path2D("M12 47L18 56L17 67A2 2 0 0 0 22 68L23 56L17 46Z"));
  }

  ctx.restore();
};

// What's on the map at coords x,y ? 0: sky, 1: solid block, 2: cube
hit = (x, y) => {
  if(map[(y/50|0) * 16 + (x/50|0)]) return 1;
  for(i in cubes){
    if(hero_hold != +i && cubes[i].x - 25 < x && cubes[i].x + 25 > x && cubes[i].y - 25 < y && cubes[i].y + 25 > y) {
      //console.log("hit " +i);
      return 2;
    }
  }
  return 0;
}

// Draw one frame (and run the physics)
draw = () => {

  var i;
  
  canvas.width ^= 0;
  
  // map
  for(x = 0; x < 16; x++){
    for(y = 0; y < 12; y++){
      if(map[y*16+x]) ctx.fillRect(x*50,y*50,50,50);
    }
  }
  
  // cubes
  for(i in cubes){
    ctx.fillStyle = "#200";
    ctx.fillRect(cubes[i].x-25, cubes[i].y-25, 50, 50);
    ctx.fillStyle = "#000";
  }
  
  // hero
  hero(
    hero_x,
    hero_y,
    hero_hold ? "hold" : (hero_grounded ? ((l || r) ? "walk" + (~~(hero_walk / 5) % 3) : "idle") : "idle"),
    hero_grounded ? ((l || r) ? "walk" + (~~(hero_walk / 4) % 3) : "idle") : "jump",
    hero_h,
    0
  );
  
  // Ascend
  if(hero_vy < 0){
    if(!hit(tl[0] +5, tl[1]) && !hit(tr[0]-5, tr[1])){
      console.log("ascend");
      hero_grounded = 0;
      hero_vy += gravity;
      hero_vy = Math.min(hero_vy, 30);
      hero_y += hero_vy;
    }
    else {
      console.log("hit ceiling");
      hero_vy = 0;
      hero_y = ~~(hero_y / 50) * 50 + (hero_hold ? 30 : 10);
    }
  }
  
  // Fall
  if(hero_vy >= 0){
    if(!hit(br[0]-5, br[1] + 5) && !hit(bl[0]+5, bl[1] + 5)){
      console.log("fall");
      hero_grounded = 0;
      hero_vy += gravity;
      hero_vy = Math.min(hero_vy, 25);
      hero_y += hero_vy;
    }
    
    // Land
    else {
      //console.log("land");
      hero_grounded = 1;
      hero_y = ~~(hero_y / 50) * 50 + 5;
      hero_vy = 0;
    }
  }
  
  // Apply physics to non-held cubes
  for(i in cubes){
    if(!cubes[i].holding){
      if(i != 0) console.log(i, hit(cubes[i].x + -24, cubes[i].y + 26), hit(cubes[i].x + 24, cubes[i].y + 26));
      if(!hit(cubes[i].x + -24, cubes[i].y + 26) && !hit(cubes[i].x + 24, cubes[i].y + 26)){
        if(i != 0) console.log("cube " + i + " not grounded");
        cubes[i].vy += gravity; // vy
        cubes[i].vy = Math.min(cubes[i].vy, 25);
        cubes[i].y += cubes[i].vy; // y += vy
      }
      else {
        //if(i != 0)console.log("cube " + i + " grounded");
        //cubes[i].grounded = 1;
        cubes[i].y = (~~(cubes[i].y / 50)) * 50+25;
        cubes[i].vy = 0;
      }
    }
  }
  
  // Left
  if(l){
  
    if(hero_x > -40 && !hit(...tl) && !hit(...ml) && !hit(bl[0], bl[1] - 10)){
      hero_x -= 6;
    }
    else{
      //hero_x = ~~(hero_x / 50) * 50 - 40;
    }
    hero_h = 1;
    hero_walk++;
  }
  
  // Right
  if(r){
    if(hero_x < 740 && !hit(...tr) && !hit(...mr) && !hit(br[0], br[1] - 10)){
      hero_x += 6;
    }
    else{
      //hero_x = ~~(hero_x / 50) * 50 + 40;
    }
    hero_h = 0;
    hero_walk++;
  }
  
  // Jump
  if(!u) u_release = 1;
  if(u && hero_grounded && u_release) {
    hero_vy += -15;
    hero_y += -20;
    hero_grounded = 0;
    u_release = 0;
  }
  
  // Hold a cube
  if(!s) s_release = 1;
  if(s && s_release) {
    s_release = 0;
    if(hero_hold) {
      console.log("release " + hero_hold);
      if(hero_h) cubes[hero_hold].x -= (hit(cubes[hero_hold].x - 40, cubes[hero_hold].y - 25) || hit(cubes[hero_hold].x - 40, cubes[hero_hold].y + 25)) ? 0 : 15;
      else cubes[hero_hold].x += (hit(cubes[hero_hold].x + 40, cubes[hero_hold].y - 25) || hit(cubes[hero_hold].x + 40, cubes[hero_hold].y + 25)) ? 0 : 15;;
      cubes[hero_hold].holding = 0;
      hero_hold = 0;
    }
    else{
      for(i in cubes){
        if(Math.abs(hero_x-cubes[i].x) < 40 && Math.abs(hero_y-cubes[i].y) < 80) {
          console.log("grab " + i);
          hero_hold = +i;
          cubes[i].holding = current_self;
          break;
        }
      }
    }
    hold_timer = 10;
  }
  if(hero_hold) {
    cubes[hero_hold].x = hero_x + (hero_h ? -20 : 20);
    cubes[hero_hold].y = hero_y - 20;
  }

  //console.log(hero_y, hero_grounded);
  
  ctx.fillStyle = "yellow";
  ctx.fillRect(tl[0], tl[1], 3,3);
  ctx.fillRect(tr[0], tr[1], 3,3);
  ctx.fillRect(bl[0], bl[1], 3,3);
  ctx.fillRect(br[0], br[1], 3,3);
  ctx.fillRect(ml[0], ml[1], 3,3);
  ctx.fillRect(mr[0], mr[1], 3,3);
  ctx.fillRect(hero_x, hero_y, 3,3);
  for(i in cubes)
    ctx.fillRect(cubes[i].x, cubes[i].y, 3,3);
}


// Launch the game
play = () => {
  // BG
  v.style.background = "linear-gradient(#300,#a00)";
  v.style.backgroundSize = "200% 200%";
  v.style.animation = "fire infinite 2s";
  devil.style.opacity = .05;
  devil.style.transform = "translateX(385px) translateY(225px) scale(7)";
  
  // Canvas
  ctx = canvas.getContext("2d");
  
  // Map
  map = [
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,
    0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,
    0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,
    0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,
    1,0,0,0,1,1,1,2,0,0,0,0,1,0,0,1,
    1,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,
    0,0,1,1,0,0,0,2,0,0,1,0,0,0,1,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  ];

  // Gameplay data:
  // At each frame, save:
  // - heros id, positions, orientation (left/right), gravity (up/down), time (forward/backward), if it's the current one, and what they're holding.
  // - for each cube: id, position, gravity, time, who holds it
  // - for each button: if it's pressed
  // The data is saved in "past" if time < 0 and in "future" if time >= 0
  past = [];

  future = [];

  present = 0; // frame number
  
  current_self = 1;

  cubes = [{x: 999, y: 999, vy: 0, grounded: 0, holding: 0}, ]; // x, y, vy, grounded. cube 0 doesn't exist
  
  // Set cubes
  for(i in map){
    if(map[i] == 2) {
      cubes.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, vy: 0, grounded: 0, holding: 0});
      map[i] = 0;
    }
  }
  console.log(cubes[1]);
  console.log(cubes);
  
  hero_x = 100;
  hero_y = 100;
  hero_vy = 0;
  gravity = 2;
  hero_grounded = 0;
  hero_h = 0;
  hero_walk = 0;
  hero_hold = 0;
  hold_timer = 0;
  
  // hitbox
  tl = tr = bl = br = ml = mr = [];
  
  // Game loop
  setInterval(draw, 33);
  
}
onload = () => play();


</script>