<link rel=stylesheet href=style.css>
<div id=v>
<h1 id=light></h1>
<div id=devil></div>
<canvas id=canvas width=800 height=600></canvas>
<div id=start></div>
<div id=exit></div>
</div>

<script>

// Special map items
$ = 10;
_ = 11;


// Keyboard controls (Up Left Down Right Space)
u=r=d=l=s=0;
onkeydown=onkeyup=e=>this['s****lurd************************l**r************l*d***u**u'[e.which-32]]=e.type[5];

lightning = () => {
  light.style.opacity = .8;
  setTimeout(()=>light.style.opacity = 0, 200);
  setTimeout(()=>light.style.opacity = .8, 300);
  setTimeout(()=>light.style.opacity = 0, 350);
}


// Render hero and update its hitbox if it is the current one
draw_hero = (x, y, arms, legs, mirror_h, mirror_v, inverted, current = 1, arms_only = 0) => {
  ctx.save();
  
  //if(current == 1) console.log(legs);
  
  if(inverted){
    ctx.fillStyle = "#ddd";
  }
  
  // Reversed gravity
  if(mirror_v){
    
    // Look left
    if(!mirror_h) {
      ctx.translate(x,y);
      ctx.rotate(Math.PI);
      ctx.translate(20,-62);
      ctx.scale(-1.5,1.5);
    }
    
    // Look right
    else {
      ctx.translate(x,y);
      ctx.rotate(Math.PI);
      ctx.translate(-17,-62);
      ctx.scale(1.5,1.5);
    }
    
    // Compute hitbox
    if(current){
      
      // Hold a cube
      if(arms == "hold"){
      
        // Look left
        if(mirror_h){
          tl = [hero.x + -10, hero.y - 45];
          tr = [hero.x + 10, hero.y - 45];
          bl = [hero.x + -45, hero.y + 45];
          br = [hero.x + 10, hero.y + 45];
          ml = [hero.x + -45, hero.y];
          mr = [hero.x + 10, hero.y];
        }
        
        // Look right
        else{
          tl = [hero.x + -10, hero.y - 45];
          tr = [hero.x + 10, hero.y - 45];
          bl = [hero.x + -10, hero.y + 45];
          br = [hero.x + 45, hero.y + 45];
          ml = [hero.x + -10, hero.y];
          mr = [hero.x + 45, hero.y];
        }
      }
      
      // Not holding stuff
      else {
        tl = [hero.x + -10, hero.y - 35];
        tr = [hero.x + 10, hero.y - 35];
        bl = [hero.x + -10, hero.y + 45];
        br = [hero.x + 10, hero.y + 45];
        ml = [hero.x + -10, hero.y];
        mr = [hero.x + 10, hero.y];
      }
    }
    
    
  }
  
  // Normal gravity
  else {
  
    // Look left
    if(mirror_h) {
      ctx.translate(x+20,y-55);
      ctx.scale(-1.5,1.5);
    }
    
    // Look right
    else {
      ctx.translate(x-17,y-55);
      ctx.scale(1.5,1.5);
    }
    
    // Compute hitbox
    if(current){
      
      // Hold a cube
      if(arms == "hold"){

        // Look left
        if(mirror_h){
          tl = [hero.x + -45, hero.y - 45];
          tr = [hero.x + 10, hero.y - 45];
          bl = [hero.x + -10, hero.y + 45];
          br = [hero.x + 10, hero.y + 45];
          ml = [hero.x + -45, hero.y];
          mr = [hero.x + 10, hero.y];
        }
        
        // Look right
        else{
          tl = [hero.x + -10, hero.y - 45];
          tr = [hero.x + 45, hero.y - 45];
          bl = [hero.x + -10, hero.y + 45];
          br = [hero.x + 10, hero.y + 45];
          ml = [hero.x + -10, hero.y];
          mr = [hero.x + 45, hero.y];
        }
      }
      
      // Not holding stuff
      else {
        tl = [hero.x + -10, hero.y - 35];
        tr = [hero.x + 10, hero.y - 35];
        bl = [hero.x + -10, hero.y + 45];
        br = [hero.x + 10, hero.y + 45];
        ml = [hero.x + -10, hero.y];
        mr = [hero.x + 10, hero.y];
      }
    }
  }
  
  // Draw:
  
  if(arms_only && arms == "hold"){
    // arms 
    ctx.fill(new Path2D("M3 28L7 41L23 41A3 3 0 0 0 23 34L11 34L9 26Z"));
  }
  
  else{
    // Body
    ctx.fill(new Path2D("M17 15L20 20L16 21ZM8 15L6 11L9 13L8 10L11 13L12 9L13 13L15 9L15 13L17 10L17 13L19 10L18 15L17 25A4 4 0 0 1 22 30L17 32L17 44A2 2 0 0 1 8 44L8 32L3 28A7 9 0 0 1 9 25Z")); // body
  
    // Arms
    if(arms == "idle" || arms == "walk1"){
      ctx.fill(new Path2D("M3 28L3 47A1 1 0 1 0 8 47L8 25Z"));
      ctx.fill(new Path2D("M22 29L22 46A1 1 0 0 1 17 46L17 25Z"));
    }
    else if(arms == "hold") {
      ctx.fill(new Path2D("M3 28L7 41L23 41A3 3 0 0 0 23 34L11 34L9 26Z"));
      ctx.fill(new Path2D("M15 26L19 38L32 38A2 2 0 0 0 32 32L24 32L20 26Z"));
    }
    else if(arms == "walk0" || arms == "jump") {
      ctx.fill(new Path2D("M16 27L18 46A1 1 0 0 0 24 44L21 26Z"));
      ctx.fill(new Path2D("M4 28L1 47A1 1 0 0 0 6 48L10 26Z"));
    }
    else if(arms == "walk2") {
      ctx.fill(new Path2D("M4 28L6 49A2 2 0 0 0 12 48L9 26Z"));
      ctx.fill(new Path2D("M16 26L14 45A1 1 0 0 0 18 47L21 28Z"));
    }
  
    // Legs
    if(legs == "idle"){
      ctx.fill(new Path2D("M12 45L12 71A2 1 0 1 0 17 71L17 43Z"));
      ctx.fill(new Path2D("M9 44L9 70A2 2 0 1 0 14 70L14 45Z"));
    }
    else if(legs == "walk2"){
      ctx.fill(new Path2D("M9 46L13 71A4 3 0 0 0 20 69L14 46Z"));
      ctx.fill(new Path2D("M11 45L6 68A2 2 0 0 0 11 70L16 46Z"));
    }
    else if(legs == "walk0"){
      ctx.fill(new Path2D("M9 46L10 69A3 5 0 0 0 15 69L14 46Z"));
      ctx.fill(new Path2D("M12 47L14 56L6 64A1 1 0 0 0 10 68L21 57L15 46Z"));
    }
    else if(legs == "jump" || legs == "walk1"){
      ctx.fill(new Path2D("M9 46L11 58L8 68A2 2 0 0 0 12 70L16 58L13 46Z"));
      ctx.fill(new Path2D("M12 47L18 56L17 67A2 2 0 0 0 22 68L23 56L17 46Z"));
    }
  
    // Triangle
    if(current >= 1){
      ctx.beginPath();
      //console.log(mirror_h);
      ctx.moveTo(mirror_h * 5 + 10,0);
      ctx.lineTo(mirror_h * 5 + 0,-10);
      ctx.lineTo(mirror_h * 5 + 20,-10);
      ctx.closePath();
      ctx.fillStyle = "#269";
      ctx.fill();
    }
  }

  ctx.restore();
};

// What's on the map at coords x,y ? 0: sky, 1: solid block, 2: cube
hit = (x, y, from_cube, log) => {
  hitx = (x/50|0) * 50 + 25;
  hity = (y/50|0) * 50 + 25;
  for(i in cubes){
    if(hero.hold != +i && !cubes[i].holding && cubes[i].x - 25 < x && cubes[i].x + 25 > x && cubes[i].y - 25 < y && cubes[i].y + 25 > y) {
      //if(log) console.log("hit " +i);
      hitx = cubes[i].x;
      hity = cubes[i].y;
      //if(log) console.log(hity);
      return 2;
    }
  }
  if(map[(y/50|0) * 16 + (x/50|0)]){
    hitx = (x/50|0) * 50 + 25;
    hity = (y/50|0) * 50 + 25;
    //if(log) console.log(hity);
    return map[(y/50|0) * 16 + (x/50|0)];
  }
  
  if(x > 950 || x < -50){
    //hitx = (x/50|0) * 50 + 25;
    //hity = (y/50|0) * 50 + 25;
    //if(log) console.log(hity);
    return 1;
  }
  return 0;
}

// Draw one frame (and run the physics)
draw = () => {

  var i,j;

  if(pause){ pause--; if(pause < 18 && pause > 5) return }
  
  time++;
  
  if(hero.inverted) present--;
  else present++;
  present_abs = Math.abs(present);
  time_array = present < 0 ? past : future;
  if(!time_array[present_abs]) time_array[present_abs] = {hero: [], cubes: []};
  
  //if(time < 100){
    
    // Save hero in time
    time_array[present_abs].hero[current_self] = JSON.parse(JSON.stringify(hero));
  
    //console.log(time_array[present_abs].hero[current_self]);
    // Load cubes from time array plus eventual cubes that have been created since
    if(time_array[present_abs].cubes.length){
      
      for(i in time_array[present_abs].cubes){
        if(cubes[i].last_grab && cubes[i].last_grab < current_self){
          cubes[i] = JSON.parse(JSON.stringify(time_array[present_abs].cubes[i]));
        }
        else {
          cubes[i] = JSON.parse(JSON.stringify(time_array[present_abs].cubes[i]));
          cubes[i].holding = 0;
        }
      }
      //cubes = time_array[present_abs].cubes;
      //console.log(present, JSON.stringify(cubes));
    }
    
    // Save cubes in time
    time_array[present_abs].cubes = JSON.parse(JSON.stringify(cubes));
    
    //console.log(time_array);
  //}
  
  
  canvas.width ^= 0;
  
  
  // map
  for(x = 0; x < 16; x++){
    for(y = 0; y < 12; y++){
    
      // 0: air (not drawn)
    
      // 1: Solid wall
      if(map[y*16+x] == 1) ctx.fillRect(x*50,y*50,50,50);
      
      // 2: cube (not drawn here)
      
      // 3: gravity reverser (not drawn here)
      
      // 4: time reverser (not drawn here)
      
      
      
    }
  }
  
  // Gravity inverters
  for(i in gravity_inverters){
    ctx.save();
    ctx.beginPath();
    if(gravity_inverters[i].active){
      ctx.fillStyle = "yellow";
      ctx.strokeStyle = "yellow";
    }
    ctx.lineWidth = 3;
    ctx.setLineDash([5, 3]);
    ctx.arc(gravity_inverters[i].x,gravity_inverters[i].y,22,0,7);
    ctx.stroke();
    ctx.translate(gravity_inverters[i].x-50,gravity_inverters[i].y-50);
    ctx.scale(.9,.9);
    ctx.translate(5,5);
    ctx.fill(new Path2D("M53 60L53 40L57 40L50 30L43 40L47 40L47 60L42 60L50 70L58 60Z"));
    ctx.restore();
  }
  
  // Cubes slots
  for(i in cube_slots){
  
    // Normal
    if(!cube_slots[i].inverted) {
      ctx.save();
      if(cube_slots[i].active) {
        ctx.fillStyle = "yellow";
        ctx.strokeStyle = "yellow";
      }
      else {
        ctx.fillStyle = "#111";
        ctx.strokeStyle = "#111";
      }
      ctx.translate(cube_slots[i].x - 25, cube_slots[i].y - 25);
      ctx.beginPath();
      ctx.lineWidth = 4;
      ctx.setLineDash([6, 5]);
      ctx.rect(0,0,50,50);
      ctx.stroke();
      ctx.translate(0,0);
      ctx.fill(new Path2D("M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
      ctx.restore();
    }
      
    // Inverted
    else {
      ctx.save();
      
      if(cube_slots[i].active) {
        ctx.fillStyle = "yellow";
        ctx.strokeStyle = "yellow";
      }
      else {
        ctx.fillStyle = "#bbb";
        ctx.strokeStyle = "#bbb";
      }
      ctx.translate(cube_slots[i].x - 25, cube_slots[i].y - 25);
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 5]);
      ctx.rect(0,0,50,50);
      ctx.stroke();
      ctx.fill(new Path2D("M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
      ctx.restore();
    }
  }
  
  
  // Time inverters
  for(i in time_inverters){
    ctx.save();
    if(time_inverters[i].active) {
      ctx.fillStyle = "yellow";
      ctx.strokeStyle = "yellow";
    }
    else {
      ctx.fillStyle = "hsl(0deg 0% " + (Math.cos(time/15)*30 + 30) + "%)";
      ctx.strokeStyle = "hsl(0deg 0% " + (Math.cos(time/15)*30 + 30) + "%)";
    }
    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.setLineDash([5, 5]);
    ctx.translate(time_inverters[i].x, time_inverters[i].y);
    ctx.arc(0,0,22,0,7);
    ctx.stroke();
    
    ctx.translate(-30,-30);
    ctx.scale(.7,.7);
    ctx.translate(-7,-7);
    ctx.fill(new Path2D("M45 40L55 51L55 42A4 4 0 0 1 60 57L60 61A6 6 0 0 0 55 37L55 30ZM55 61L45 50L45 57A2 2 0 1 1 40 44L40 39A8 8 0 0 0 45 62L45 70Z"));
    ctx.restore();
  }
  
    
  
  // Non-held cubes
  for(i in cubes){
    if(cubes[i].holding) continue;
    ctx.save();
    if(cubes[i].inverted){
      ctx.fillStyle = "#ddd";
    }
    else {
      ctx.fillStyle = "#000";
    }
    ctx.translate(cubes[i].x, cubes[i].y);
    if(cubes[i].mirror_v){
      ctx.rotate(Math.PI);
      ctx.translate(0,-.5);
    }
    ctx.translate(-25,-25);
    
    ctx.fill(new Path2D("M9 0.5L40 0.5A10 9 0 0 1 50 9L50 40A10 10 0 0 1 40 50L9 50A9 10 0 0 1 1 40L0 9A9 9 0 0 1 9 0M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
    ctx.fillStyle = "#7008";
    ctx.fill(new Path2D("M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
    ctx.fillStyle = "#000";
    //ctx.fillText(i, 60, 30);
    ctx.restore();
  }
  
  
  // Previous selves
  for(i in time_array[present_abs]?.hero){
    j = time_array[present_abs].hero[i];
    //if(i == 1) console.log(j.walk);
    draw_hero(
      j.x,
      j.y,
      j.hold ? "hold" : (j.grounded ? (j.walking ? "walk" + (~~(j.walk / 5) % 3) : "idle") : "jump"),
      j.grounded ? (j.walking ? "walk" + (~~(j.walk / 4) % 3) : "idle") : "jump",
      j.mirror_h,
      j.mirror_v,
      j.inverted,
      j
    );
    
    // Detect paradox (past self standing on non existing cube)
    //if(i==1)console.log(j, j.stand_on_cube);
    
    if(j.hold){
      
      // Previous self cube
      ctx.save();
      if(cubes[j.hold].inverted){
        ctx.fillStyle = "#ddd";
      }
      else {
        ctx.fillStyle = "#000";
      }
      ctx.translate(cubes[j.hold].x, cubes[j.hold].y);
      if(cubes[j.hold].mirror_v){
        ctx.rotate(Math.PI);
        ctx.translate(0,-.5);
      }
      ctx.translate(-25,-25);
      
      ctx.fill(new Path2D("M9 0.5L40 0.5A10 9 0 0 1 50 9L50 40A10 10 0 0 1 40 50L9 50A9 10 0 0 1 1 40L0 9A9 9 0 0 1 9 0M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
      ctx.fillStyle = "#7008";
      ctx.fill(new Path2D("M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
      ctx.fillStyle = "#000";
      //ctx.fillText(i, 60, 30);
      ctx.restore();
  
      // Previous self arms
      j = time_array[present_abs].hero[i];
      //if(i == 1) console.log(j.walk);
      draw_hero(
        j.x,
        j.y,
        j.hold ? "hold" : (j.grounded ? (j.walking ? "walk" + (~~(j.walk / 5) % 3) : "idle") : "jump"),
        j.grounded ? (j.walking ? "walk" + (~~(j.walk / 4) % 3) : "idle") : "jump",
        j.mirror_h,
        j.mirror_v,
        j.inverted,
        j,
        true
      );
    }
  }
  
  // current hero
  draw_hero(
    hero.x,
    hero.y,
    hero.hold ? "hold" : (hero.grounded ? (hero.walking ? "walk" + (~~(hero.walk / 5) % 3) : "idle") : "jump"),
    hero.grounded ? (hero.walking ? "walk" + (~~(hero.walk / 4) % 3) : "idle") : "jump",
    hero.mirror_h,
    hero.mirror_v,
    hero.inverted,
    current_self
  );
  
  if(hero.hold){
  
    // Hero's cube
    ctx.save();
    if(cubes[hero.hold].inverted){
      ctx.fillStyle = "#ddd";
    }
    else {
      ctx.fillStyle = "#000";
    }
    ctx.translate(cubes[hero.hold].x, cubes[hero.hold].y);
    if(cubes[hero.hold].mirror_v){
      ctx.rotate(Math.PI);
      ctx.translate(0,-.5);
    }
    ctx.translate(-25,-25);
    
    ctx.fill(new Path2D("M9 0.5L40 0.5A10 9 0 0 1 50 9L50 40A10 10 0 0 1 40 50L9 50A9 10 0 0 1 1 40L0 9A9 9 0 0 1 9 0M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
    ctx.fillStyle = "#7008";
    ctx.fill(new Path2D("M35 20A3 3 0 0 0 25 20A5 5 0 0 0 15 20Q15 25 25 35Q35 25 35 20"));
    ctx.fillStyle = "#000";
    //ctx.fillText(i, 60, 30);
    ctx.restore();

    // hero's arms
    draw_hero(
      hero.x,
      hero.y,
      hero.hold ? "hold" : (hero.grounded ? (hero.walking ? "walk" + (~~(hero.walk / 5) % 3) : "idle") : "jump"),
      hero.grounded ? (hero.walking ? "walk" + (~~(hero.walk / 4) % 3) : "idle") : "jump",
      hero.mirror_h,
      hero.mirror_v,
      hero.inverted,
      current_self,
      true
    );
  }
  

  if(hero.mirror_v){
    hero_physics_v();
  }
  else {
    hero_physics();
  }
  
  // Apply physics to non-held cubes
  for(i in cubes){
  
    // reversed gravity
    if(cubes[i].mirror_v){
      
      // Cube fall
      if(!cubes[i].holding){
        if(
          (hit(cubes[i].x  -22, cubes[i].y - 26, 1) == 0 || hit(cubes[i].x + -22, cubes[i].y - 26, 1) > 2)
          &&
          (hit(cubes[i].x + 22, cubes[i].y - 26, 1) == 0 || hit(cubes[i].x + 22, cubes[i].y - 26, 1) > 2)
        ){
          cubes[i].vy += gravity; // vy
          cubes[i].vy = Math.min(cubes[i].vy, 15);
          cubes[i].y -= cubes[i].vy; // y -= vy
        }
        
        // Cube grounded
        else {
          cubes[i].y = (~~(cubes[i].y / 50)) * 50+25;
          cubes[i].vy = 0;
        }
      }
    
    }
    
    else {
    
      // Cube fall
      if(!cubes[i].holding){
        if(
          (hit(cubes[i].x  -22, cubes[i].y + 26, 1) == 0 || hit(cubes[i].x + -22, cubes[i].y + 26, 1) > 2)
          &&
          (hit(cubes[i].x + 22, cubes[i].y + 26, 1) == 0 || hit(cubes[i].x + 22, cubes[i].y + 26, 1) > 2)
        ){
          cubes[i].vy += gravity; // vy
          cubes[i].vy = Math.min(cubes[i].vy, 15);
          cubes[i].y += cubes[i].vy; // y += vy
        }
        
        // Cube grounded
        else {
          cubes[i].y = (~~(cubes[i].y / 50)) * 50+25;
          cubes[i].vy = 0;
        }
      }

    }
  }
  
  
  // gravity inverter for hero
  if(herogravitydelay == 0) {
    for(i in gravity_inverters){
      if(gravity_inverters[i].x + 25 > bl[0] && gravity_inverters[i].x - 25 < br[0] && gravity_inverters[i].y + 25 > tl[1] && gravity_inverters[i].y - 25 < bl[1]){
        gravity_inverters[i].active = 1;
        hero.mirror_v = 1 - hero.mirror_v;
        if(hero.hold){
          cubes[hero.hold].mirror_v = 1 - cubes[hero.hold].mirror_v;
          hero.vy = 0;
        }
        herogravitydelay = 15;
        pause = 20;
      }
      else {
        gravity_inverters[i].active = 0;
      }
    }
  }
  else {
    herogravitydelay --;
    if(herogravitydelay == 13) v.style.transform = "rotateX(" + (canvasrx = 180 - canvasrx) + "deg)";
  }
  
  
  // gravity inverter for cubes
  for(j in cubes){
    if(cubes[j].gravitydelay == 0 && !cubes[j].holding) {
      for(i in gravity_inverters){
        //if(i == 5 && j == 8) console.log(gravity_inverters[i], cubes[j])
        if(gravity_inverters[i].x + 25 > cubes[j].x - 25 && gravity_inverters[i].x - 25 < cubes[j].x + 25 && gravity_inverters[i].y + 25 > cubes[j].y - 25 && gravity_inverters[i].y - 25 < cubes[j].y + 25){
          gravity_inverters[i].active = 1;
          cubes[j].mirror_v = 1 - cubes[j].mirror_v;
          cubes[j].gravitydelay = 1;
        }
        else {
          //gravity_inverters[i].active = 0;
        }
      }
    }
    else {
      if(cubes[j].gravitydelay) cubes[j].gravitydelay --;
    }
  }
  
  
  // time inverter for hero
  for(i in time_inverters){
    if(!time_inverters[i].active && time_inverters[i].x + 25 > bl[0] && time_inverters[i].x - 25 < br[0] && time_inverters[i].y + 25 > tl[1] && time_inverters[i].y - 30 < bl[1]){
      time_inverters[i].active = 1;
      lightning();
      hero.inverted = 1 - hero.inverted;
      current_self++;
      if(hero.hold){
      
        // Make cube disappear "after" the time inversion (before if time is reversed)
        if(hero.inverted){
          if(!time_array[Math.abs(present + 1)]){
            time_array[Math.abs(present + 1)] = JSON.parse(JSON.stringify(time_array[present_abs]));
          }
          time_array[Math.abs(present + 1)].cubes[hero.hold].x = 9999;
        }
        else {
          if(!time_array[Math.abs(present - 1)]){
            time_array[Math.abs(present - 1)] = JSON.parse(JSON.stringify(time_array[present_abs]));
          }
          time_array[Math.abs(present - 1)].cubes[hero.hold].x = 9999;
        }
        
        
        // New cube is created in the opposite direction and attached to the new self
        cubes[cubes.length] = JSON.parse(JSON.stringify(cubes[cubes.length-1]));
        //console.log(JSON.stringify(cubes));
        hero.hold = cubes.length - 1;
        cubes[hero.hold].holding = current_self;
        cubes[hero.hold].inverted = 1 - cubes[hero.hold].inverted;
        
      }
      //herogravitydelay = 9;
      //pause = 20;
    }
    else if(!(time_inverters[i].x + 25 > bl[0] && time_inverters[i].x - 25 < br[0] && time_inverters[i].y + 25 > tl[1] && time_inverters[i].y - 30 < bl[1])){
      time_inverters[i].active = 0;
    }
  }
  
  
  // cube slots
  exit_open = 1;
  for(i in cube_slots){
    cube_slots[i].active = 0;
  }
  for(j in cubes){
    if(!cubes[j].holding) {
      for(i in cube_slots){
        if(cube_slots[i].inverted == cubes[j].inverted){
          //if(i == 5 && j == 8) console.log(cube_slots[i], cubes[j])
          if(cube_slots[i].x + 25 > cubes[j].x - 25 && cube_slots[i].x - 25 < cubes[j].x + 25 && cube_slots[i].y + 25 > cubes[j].y - 25 && cube_slots[i].y - 25 < cubes[j].y + 25){
            cube_slots[i].active = 1;
          }
        }
      }
    }
    else {
      if(cubes[j].gravitydelay) cubes[j].gravitydelay --;
    }
  }
  if(cube_slots.length == 0) exit_open = 0;
  for(i in cube_slots){
    if(!cube_slots[i].active) exit_open = 0;
  }
  exit.style.opacity = exit_open ? 1 : 0.5;
  exit.style.transform = exit_open ? "scale(1)" : "scale(.2)";
  
  
  
  
  //console.log(herogravitydelay, hero.mirror_v);

  //console.log(hero.y, hero.grounded);
  
  ctx.fillStyle = "yellow";
  /*
  ctx.fillRect(tl[0], tl[1], 3,3);
  ctx.fillRect(tr[0], tr[1], 3,3);
  ctx.fillRect(bl[0], bl[1], 3,3);
  ctx.fillRect(br[0], br[1], 3,3);
  ctx.fillRect(ml[0], ml[1], 3,3);
  ctx.fillRect(mr[0], mr[1], 3,3);
  ctx.fillRect(hero.x, hero.y, 3,3);
  */
  for(i in cubes){
    //ctx.fillRect(cubes[i].x, cubes[i].y, 3,3);
    //ctx.fillText(i, cubes[i].x + 30, cubes[i].y);
    
  }
  
  for(i in gravity_inverters){
    //ctx.fillRect(cubes[i].x, cubes[i].y, 3,3);
    //ctx.fillText(i, gravity_inverters[i].x + 30, gravity_inverters[i].y);
    
  }
  
  //console.log(cubes[2].last_grab);
}


// Launch the game
play = () => {
  // BG
  v.style.background = "linear-gradient(#300,#a00)";
  v.style.backgroundSize = "200% 200%";
  v.style.animation = "fire infinite 2s";
  devil.style.opacity = .05;
  devil.style.transform = "translateX(385px) translateY(225px) scale(7)";
  
  // Canvas
  ctx = canvas.getContext("2d");
  
  // Map
  // 0: sky
  // 1: wall/ground
  // 2: cube 
  // 3: gravity reverser
  // 4: time reverser
  // 5: cube slot
  // 6: exit
  // 7: time-inverted cube
  // 8: reversed cube
  // 9: reversed cube slot
  // $: start
  map = [
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    0,0,3,0,0,1,0,0,0,1,0,8,0,9,0,0,
    0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,6,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,$,0,0,0,0,
    0,1,0,0,0,3,0,0,0,0,0,0,0,0,0,0,
    0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
    0,1,0,0,1,1,1,0,7,0,0,5,0,0,4,0,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  ];

  // Gameplay data:
  // At each frame, save:
  // - heros id, positions, orientation (left/right), gravity (up/down), time (forward/backward), if it's the current one, and what they're holding.
  // - for each cube: id, position, gravity, time, who holds it
  // - for each button: if it's pressed
  // The data is saved in "past" if time < 0 and in "future" if time >= 0
  past = [];

  future = [];

  present = 0; // frame number
  present_abs = 0; // same but absolute value
  
  current_self = 1;

  cubes = [{x: 999, y: 999, vy: 0, grounded: 0, holding: 0, mirror_v: 0, gravitydelay: 0, last_grab: 0}, ]; // x, y, vy, grounded. cube 0 doesn't exist
  
  gravity_inverters = [];
  
  cube_slots = [];
  
  time_inverters = [];
  
  exit_open = 0;
  
    hero = {
    x: 0,
    y: 0,
    vy: 0,
    grounded: 0,
    walk: 0,
    hold: 0,
    mirror_v: 0,
    mirror_h: 0,
    inverted: 0,
  };
  
  
  // Set cubes and inverters
  for(i in map){
    
    if(map[i] == 2) {
      cubes.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, vy: 0, grounded: 0, holding: 0,mirror_v: 0, inverted: 0, gravitydelay: 0, last_grab: 0});
      map[i] = 0;
    }
    
    if(map[i] == 3) {
      gravity_inverters.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, active: 0});
      map[i] = 0;
    }
    
    if(map[i] == 4) {
      time_inverters.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, active: 0});
      map[i] = 0;
    }
    
    if(map[i] == 5) {
      cube_slots.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, active: 0, inverted: 0});
      map[i] = 0;
    }
    
    if(map[i] == 6){
      exit.style.left = (~~(i%16) * 50 + 25 - 75) + "px";
      exit.style.top = (~~(i/16) * 50+25 - 75) + "px";
    }
    
    if(map[i] == 7) {
      cubes.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, vy: 0, grounded: 0, holding: 0,mirror_v: 0, inverted: 1, gravitydelay: 0, last_grab: 0});
      map[i] = 0;
    }
  
    if(map[i] == 8) {
      cubes.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, vy: 0, grounded: 0, holding: 0,mirror_v: 1, inverted: 0, gravitydelay: 0, last_grab: 0});
      map[i] = 0;
    }
    
    if(map[i] == 9) {
      cube_slots.push({x: ~~(i%16) * 50+25, y: ~~(i/16) * 50+25, active: 0, inverted: 1});
      map[i] = 0;
    }
    
    if(map[i] == $) {
      start.style.left = (~~(i%16) * 50 + 25 - 75) + "px";
      start.style.top = (~~(i/16) * 50+25 - 75) + "px";
      start.style.transform = "scale(.2)";
      hero.x = ~~(i%16) * 50+25;
      hero.y = ~~(i/16) * 50+25;
      map[i] = 0;
    }
    
  }
  //console.log(cubes[1]);
  //console.log(cubes);
  

  
  //hero.x = 300;
  //hero.y = 200;
  //hero.vy = 0;
  gravity = 2;
  //hero.grounded = 0;
  //hero.h = 0;
  //hero.walk = 0;
  //hero.hold = 0;
  hold_timer = 0;
  canextendhitbox = 1;
  obstacle1 = obstacle2 = null;
  obstacle3 = obstacle4 = null;
  herogravitydelay = 0;
  hitx = hity = 0;
  //hero.mirror_v = 0;
  canvasrx = 0;
  pause = 0;
  time = 0;
  
  // hitbox
  tl = tr = bl = br = ml = mr = [];
  
  // Game loop
  setInterval(draw, 30);
  
}


hero_physics = () => {
  // Ascend
  if(hero.vy < 0){
    if(hit(tl[0] +5, tl[1]) != 1 && hit(tr[0]-5, tr[1]) != 1){
      //console.log("ascend");
      hero.grounded = 0;
      hero.vy += gravity;
      hero.vy = Math.min(hero.vy, 30);
      hero.y += hero.vy;
    }
    else {
      //console.log("hit ceiling");
      hero.vy = 0;
      hero.y = ~~(hero.y / 50) * 50 + (hero.hold ? 30 : 10);
    }
  }
  
  // Fall
  hero.stand_on_cube = 0;
  
  if(hero.vy >= 0){
    obstacle1 = hit(bl[0] + 5, bl[1] + 5, 0, 1);
    //console.log(hit1y = hity);
    obstacle2 = hit(br[0] - 5, br[1] + 5);
    //console.log(hit2y = hity);
    obstacle3 = hit(ml[0] + 5, ml[1] + 5, 1);
    //console.log(hit3y = hity);
    obstacle4 = hit(mr[0] - 5, mr[1] + 5, 1);
    //console.log(hit4y = hity);
    
    // solid block
    if(obstacle3 == 1 || obstacle4 == 1){
      //console.log("land2");
      //console.log(hero.y, hity);
      hero.grounded = 1;
      hero.y = hity - 30;
      //console.log(hero.y);
      hero.vy = 0;
    }
    else if(obstacle1 == 1 || obstacle2 == 1){
      //console.log("land1");
      //console.log(hero.y, hity);
      
      hero.grounded = 1;
      hero.y = hity - 25;
      //console.log(hero.y);
      hero.vy = 0;
    }
    
    // cube
    else if(obstacle1 == 2 || obstacle2 == 2 || obstacle3 == 2 || obstacle4 == 2){
      //console.log("land");
      
      console.log(hero.stand_on_cube = 1);
      hero.grounded = 1;
      //hero.y = ~~(hero.y + 5 / 50) * 50 -50 + 5;
      hero.vy = 0;
    }
    
    // fall
    else {
      //console.log("fall");
      hero.grounded = 0;
      hero.vy += gravity;
      hero.vy = Math.min(hero.vy, 25);
      hero.y += hero.vy;
    }
  }
  
  
  
  // Left
  hero.walking = 0;
  if(l){
    obstacle1 = hit(tl[0] - 5, tl[1]);
    obstacle2 = hit(ml[0] - 5, ml[1]);
    obstacle3 = hit(bl[0] - 5, bl[1] - 10);
    
    if(hero.x > 10 && obstacle1 != 1 && obstacle2 != 1 && obstacle3 != 1){
      hero.x -= 5;
    }
    else{
      if(hero.hold){
        if(!obstacle1 == 1 && !obstacle2 == 1 && obstacle3 == 1){
          hero.x = ~~(hero.x / 50) * 50 +5;
        }
        else {
          hero.x = ~~(hero.x / 50) * 50 + 45;
        }
        //console.log(1, obstacle1, obstacle2, obstacle3);
      }
      else {
        hero.x = ~~(hero.x / 50) * 50 + 5;
      }
    }
    hero.mirror_h = 1;
    hero.walk++;
    hero.walking = 1;
  }
  
  // Right
  if(r){
    if(hero.x < 790 && hit(...tr) != 1 && hit(...mr) != 1 && hit(br[0], br[1] - 10) != 1){
      hero.x += 5;
    }
    else{
      //if(!hero.hold) hero.x = ~~(hero.x / 50) * 50  + 50 - 15;
    }
    hero.mirror_h = 0;
    hero.walk++;
    hero.walking = 1;
  }
  
  // Jump
  if(!u) u_release = 1;
  if(u && hero.grounded && u_release) {
    hero.vy += -13;
    hero.y += -13;
    hero.grounded = 0;
    u_release = 0;
    hero.walking = 0;
  }
  
  // Hold a cube
  if(!s) s_release = 1;
  if(s && s_release) {
    s_release = 0;
    if(hero.hold) {
      //console.log("release " + hero.hold);
      if(hero.mirror_h) cubes[hero.hold].x -= (hit(cubes[hero.hold].x - 40, cubes[hero.hold].y - 25) == 1 || hit(cubes[hero.hold].x - 40, cubes[hero.hold].y + 25) == 1) ? -5 : 15;
      else cubes[hero.hold].x += (hit(cubes[hero.hold].x + 40, cubes[hero.hold].y - 25) == 1 || hit(cubes[hero.hold].x + 40, cubes[hero.hold].y + 25) == 1) ? -5 : 15;
      cubes[hero.hold].holding = 0;
      hero.hold = 0;
    }
    else{
      for(i in cubes){
        if(!cubes[i].holding && Math.abs(hero.x-cubes[i].x) < 40 && Math.abs(hero.y + 30 -cubes[i].y) < 80) {
          if(Math.abs(hero.y-cubes[i].y) > 40 || (hero.mirror_h ? (hero.x > cubes[i].x - 25) : (hero.x < cubes[i].x + 25))){
            if(hero.y < cubes[i].y - 25){
              obstacle1 = hit(tl[0] - 40, tl[1]);
              obstacle2 = hit(ml[0] - 40, ml[1]);
              //console.log(1);
              if(obstacle1 == 1 || obstacle2 == 1){
                hero.x = hitx + 80;
              }
              
              obstacle1 = hit(tr[0] + 40, tr[1]);
              obstacle2 = hit(mr[0] + 40, mr[1]);
              //console.log(1);
              if(obstacle1 == 1 || obstacle2 == 1){
                hero.x = hitx - 80;
              }
            }
            //console.log("grab " + i);
            hero.hold = +i;
            cubes[i].holding = current_self;
            cubes[i].last_grab = current_self;
            break;
          }
        }
      }
    }
    hold_timer = 10;
  }
  if(hero.hold) {
    time_array[present_abs].cubes[hero.hold].holding = cubes[hero.hold].holding = current_self;
    time_array[present_abs].cubes[hero.hold].x = cubes[hero.hold].x = hero.x + (canextendhitbox ? (hero.mirror_h ? -25 : 25) : 0);
    time_array[present_abs].cubes[hero.hold].y = cubes[hero.hold].y = hero.y - 20;
    //console.log(cubes[hero.hold].y, hero.y - 20, JSON.stringify(cubes[hero.hold]));
  }
}


hero_physics_v = () => {
  // Ascend
  if(hero.vy < 0){
    if(hit(bl[0] +5, bl[1]) != 1 && hit(br[0]-5, br[1]) != 1){
      //console.log("ascend");
      hero.grounded = 0;
      hero.vy += gravity;
      hero.vy = Math.min(hero.vy, 30);
      hero.y -= hero.vy;
    }
    else {
      //console.log("hit ceiling");
      hero.vy = 0;
      hero.y = ~~(hero.y / 50) * 50 + (hero.hold ? 30 : 10);
    }
  }
  
  // Fall
    hero.stand_on_cube = 0;
  if(hero.vy >= 0){
    obstacle1 = hit(tl[0] + 5, tl[1] - 5, 0, 1);
    //console.log(hit1y = hity);
    obstacle2 = hit(tr[0] - 5, tr[1] - 5);
    //console.log(hit2y = hity);
    obstacle3 = hit(ml[0] + 5, ml[1] - 5, 1);
    //console.log(hit3y = hity);
    obstacle4 = hit(mr[0] - 5, mr[1] - 5, 1);
    //console.log(hit4y = hity);
    
    // solid block
    if(obstacle3 == 1 || obstacle4 == 1){
      //console.log("land2");
      //console.log(hero.y, hity);
      hero.grounded = 1;
      hero.y = hity + (hero.hold ? 25 : 20);
      
      //console.log(hero.y);
      hero.vy = 0;
    }
    else if(obstacle1 == 1 || obstacle2 == 1){
      //console.log("land1");
      //console.log(hero.y, hity);
      
      hero.grounded = 1;
      hero.y = hity + (hero.hold ? 20 : 12);
      //console.log(hero.y);
      hero.vy = 0;
    }
    
    // cube
    else if(obstacle1 == 2 || obstacle2 == 2 || obstacle3 == 2 || obstacle4 == 2){
      //console.log("land");
      hero.stand_on_cube = 1;
      hero.grounded = 1;
      //hero.y = ~~(hero.y + 5 / 50) * 50 -50 + 5;
      hero.vy = 0;
    }
    
    // fall
    else {
      //console.log("fall");
      hero.grounded = 0;
      hero.vy += gravity;
      hero.vy = Math.min(hero.vy, 25);
      hero.y -= hero.vy;
    }
  }
  
  // Left
  hero.walking = 0;
  if(l){
  
    /*if(hero.x > 10 && hit(...tl) != 1 && hit(...ml) != 1 && hit(bl[0], bl[1] - 10) != 1){
      hero.x -= 5;
    }
    else{
      if(!hero.hold) hero.x = ~~(hero.x / 50) * 50 + 5;
    }
    hero.mirror_h = 1;
    hero.walk++;
    hero.walking = 1;*/
    
    obstacle1 = hit(tl[0] - 5, tl[1]);
    obstacle2 = hit(ml[0] - 5, ml[1]);
    obstacle3 = hit(bl[0] - 5, bl[1] - 10);
    
    if(hero.x > 10 && obstacle1 != 1 && obstacle2 != 1 && obstacle3 != 1){
      hero.x -= 5;
    }
    else{
      if(hero.hold){
        if(!obstacle1 == 1 && !obstacle2 == 1 && obstacle3 == 1){
          hero.x = ~~(hero.x / 50) * 50 +5;
        }
        else {
          hero.x = ~~(hero.x / 50) * 50 + 45;
        }
        console.log(1, obstacle1, obstacle2, obstacle3);
      }
      else {
        hero.x = ~~(hero.x / 50) * 50 + 5;
      }
    }
    hero.mirror_h = 1;
    hero.walk++;
    hero.walking = 1;
  
  }
  
  // Right
  if(r){
    if(hero.x < 790 && hit(...tr) != 1 && hit(...mr) != 1 && hit(br[0], br[1] - 10) != 1){
      hero.x += 5;
    }
    else{
      //if(!hero.hold) hero.x = ~~(hero.x / 50) * 50  + 50 - 15;
    }
    hero.mirror_h = 0;
    hero.walk++;
    hero.walking = 1;
  }
  
  // Jump
  if(!u) u_release = 1;
  if(u && hero.grounded && u_release) {
    hero.vy -= hero.mirror_h ? 14 : 13;
    hero.y += 14;
    hero.grounded = 0;
    u_release = 0;
    hero.walking = 0;
  }
  
  // Hold a cube
  if(!s) s_release = 1;
  if(s && s_release) {
    s_release = 0;
    if(hero.hold) {
      //console.log("release " + hero.hold);
      if(hero.mirror_h) cubes[hero.hold].x -= (hit(cubes[hero.hold].x - 40, cubes[hero.hold].y - 25) == 1 || hit(cubes[hero.hold].x - 40, cubes[hero.hold].y + 25) == 1) ? -5 : 15;
      else cubes[hero.hold].x += (hit(cubes[hero.hold].x + 40, cubes[hero.hold].y - 25) == 1 || hit(cubes[hero.hold].x + 40, cubes[hero.hold].y + 25) == 1) ? -5 : 15;
      cubes[hero.hold].holding = 0;
      hero.hold = 0;
    }
    else{
      for(i in cubes){
        if(!cubes[i].holding && Math.abs(hero.x-cubes[i].x) < 40 && Math.abs(hero.y-cubes[i].y) < 80) {
          if(Math.abs(hero.y-cubes[i].y) > 40 || (hero.mirror_h ? (hero.x > cubes[i].x - 25) : (hero.x < cubes[i].x + 25))){
            if(hero.y > cubes[i].y + 25){
              obstacle1 = hit(tl[0] - 40, tl[1]);
              obstacle2 = hit(ml[0] - 40, ml[1]);
              //console.log(1);
              if(obstacle1 == 1 || obstacle2 == 1){
                hero.x = hitx + 80;
              }
              
              obstacle1 = hit(tr[0] + 40, tr[1]);
              obstacle2 = hit(mr[0] + 40, mr[1]);
              //console.log(1);
              if(obstacle1 == 1 || obstacle2 == 1){
                hero.x = hitx - 80;
              }
            }
            //console.log("grab " + i);
            hero.hold = +i;
            cubes[i].holding = current_self;
            cubes[i].last_grab = current_self;
            break;
          }
        }
      }
    }
    hold_timer = 10;
  }
  if(hero.hold) {
    time_array[present_abs].cubes[hero.hold].x = cubes[hero.hold].x = hero.x + (canextendhitbox ? (hero.mirror_h ? -25 : 25) : 0);
    time_array[present_abs].cubes[hero.hold].y = cubes[hero.hold].y = hero.y + 25;
    
    //console.log(cubes[hero.hold].y, hero.y + 25, cubes[hero.hold]);
  }
}

onload = () => play();

</script>